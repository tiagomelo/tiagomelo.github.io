<p><img src="/assets/images/2024-05-02-goprojconfig-opensource/banner.png" alt="banner" /></p>

<p>Based on a <a href="https://tiagomelo.info/quicktip/go/envconfig/2024/04/08/golang-envconfig-pdf-post.html">previous post</a>, I’ve decided to put together <a href="https://github.com/tiagomelo/go-project-config">go-project-config</a>, a simple utility tool to provide a clean and neat way for managing configuration data from environment variables for your Go project.</p>

<p><em>check out my other open source projects <a href="https://tiagomelo.info/opensource/">here</a></em></p>

<h2 id="installation">installation</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go install github.com/tiagomelo/go-project-config/cmd/goprojconfig
</code></pre></div></div>

<p>It will be installed into <code class="language-plaintext highlighter-rouge">bin</code> directory of your <code class="language-plaintext highlighter-rouge">$GOPATH</code> env.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go env | grep GOPATH
</code></pre></div></div>

<h2 id="usage">usage</h2>

<h3 id="generating-config">generating config</h3>

<p>At your project’s root:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>goprojconfig -p &lt;packageName&gt;
</code></pre></div></div>

<p>Let’s use <code class="language-plaintext highlighter-rouge">appcfg</code> as an example.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>goprojconfig -p appcfg
</code></pre></div></div>

<p>Then, three files will be generated at project’s root:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">.env</code></li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SAMPLE_ENV_VAR=some value
</code></pre></div></div>

<ol>
  <li><code class="language-plaintext highlighter-rouge">appcfg/config.go</code></li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package appcfg

import (
	"github.com/joho/godotenv"
	"github.com/kelseyhightower/envconfig"
	"github.com/pkg/errors"
)

// Config holds all configuration needed by this app.
type Config struct {
	SampleEnvVar string `envconfig:"SAMPLE_ENV_VAR" required:"true"`
}

// For ease of unit testing.
var (
	godotenvLoad     = godotenv.Load
	envconfigProcess = envconfig.Process
)

// Read reads configuration from environment variables.
// It assumes that an '.env' file is present at current path.
func Read() (*Config, error) {
	if err := godotenvLoad(); err != nil {
		return nil, errors.Wrap(err, "loading env vars from .env file")
	}
	config := new(Config)
	if err := envconfigProcess("", config); err != nil {
		return nil, errors.Wrap(err, "processing env vars")
	}
	return config, nil
}

// ReadFromEnvFile reads configuration from the specified environment file.
func ReadFromEnvFile(envFilePath string) (*Config, error) {
	if err := godotenvLoad(envFilePath); err != nil {
		return nil, errors.Wrapf(err, "loading env vars from %s", envFilePath)
	}
	config := new(Config)
	if err := envconfigProcess("", config); err != nil {
		return nil, errors.Wrap(err, "processing env vars")
	}
	return config, nil
}

</code></pre></div></div>

<ol>
  <li><code class="language-plaintext highlighter-rouge">appcfg/config_test.go</code></li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package appcfg

import (
	"errors"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestRead(t *testing.T) {
	testCases := []struct {
		name                   string
		mockedGodotenvLoad     func(filenames ...string) (err error)
		mockedEnvconfigProcess func(prefix string, spec interface{}) error
		expectedError          error
	}{
		{
			name: "happy path",
			mockedGodotenvLoad: func(filenames ...string) (err error) {
				return nil
			},
			mockedEnvconfigProcess: func(prefix string, spec interface{}) error {
				return nil
			},
		},
		{
			name: "error loading env vars",
			mockedGodotenvLoad: func(filenames ...string) (err error) {
				return errors.New("random error")
			},
			expectedError: errors.New("loading env vars from .env file: random error"),
		},
		{
			name: "error processing env vars",
			mockedGodotenvLoad: func(filenames ...string) (err error) {
				return nil
			},
			mockedEnvconfigProcess: func(prefix string, spec interface{}) error {
				return errors.New("random error")
			},
			expectedError: errors.New("processing env vars: random error"),
		},
	}
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			godotenvLoad = tc.mockedGodotenvLoad
			envconfigProcess = tc.mockedEnvconfigProcess
			config, err := Read()
			if err != nil {
				if tc.expectedError == nil {
					t.Fatalf("expected no error, got %v", err)
				}
				require.Nil(t, config)
				require.Equal(t, tc.expectedError.Error(), err.Error())
			} else {
				if tc.expectedError != nil {
					t.Fatalf("expected error, got nil")
				}
				require.NotNil(t, config)
			}
		})
	}
}

func TestReadFromEnvFile(t *testing.T) {
	testCases := []struct {
		name                   string
		mockedGodotenvLoad     func(filenames ...string) (err error)
		mockedEnvconfigProcess func(prefix string, spec interface{}) error
		expectedError          error
	}{
		{
			name: "happy path",
			mockedGodotenvLoad: func(filenames ...string) (err error) {
				return nil
			},
			mockedEnvconfigProcess: func(prefix string, spec interface{}) error {
				return nil
			},
		},
		{
			name: "error loading env vars",
			mockedGodotenvLoad: func(filenames ...string) (err error) {
				return errors.New("random error")
			},
			expectedError: errors.New("loading env vars from path/to/.env: random error"),
		},
		{
			name: "error processing env vars",
			mockedGodotenvLoad: func(filenames ...string) (err error) {
				return nil
			},
			mockedEnvconfigProcess: func(prefix string, spec interface{}) error {
				return errors.New("random error")
			},
			expectedError: errors.New("processing env vars: random error"),
		},
	}
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			godotenvLoad = tc.mockedGodotenvLoad
			envconfigProcess = tc.mockedEnvconfigProcess
			config, err := ReadFromEnvFile("path/to/.env")
			if err != nil {
				if tc.expectedError == nil {
					t.Fatalf("expected no error, got %v", err)
				}
				require.Nil(t, config)
				require.Equal(t, tc.expectedError.Error(), err.Error())
			} else {
				if tc.expectedError != nil {
					t.Fatalf("expected error, got nil")
				}
				require.NotNil(t, config)
			}
		})
	}
}

</code></pre></div></div>

<h3 id="generating-config-from-an-existing-env-file">generating config from an existing env file</h3>

<p>Suppose an env file called <code class="language-plaintext highlighter-rouge">.env-local</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>KAFKA_BROKER_HOST=localhost:9092
KAFKA_TOPIC=sometopic
KAFKA_GROUP_ID=some-group-id

MONGODB_DATABASE=somedb
MONGODB_HOST_NAME=localhost
MONGODB_PORT=27017
</code></pre></div></div>

<p>At your project’s root:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>goprojconfig -p &lt;package_name&gt; -e &lt;/path/to/envfile&gt;
</code></pre></div></div>

<p>Let’s use <code class="language-plaintext highlighter-rouge">appcfg</code> as package name again, for example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>goprojconfig -p appcfg -e .env-local
</code></pre></div></div>

<p>Then, two files will be generated at project’s root:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">appcfg/config.go</code></li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package appcfg

import (
	"github.com/joho/godotenv"
	"github.com/kelseyhightower/envconfig"
	"github.com/pkg/errors"
)

// Config holds all configuration needed by this app.
type Config struct {
	SampleEnvVar string `envconfig:"SAMPLE_ENV_VAR" required:"true"`
}

// For ease of unit testing.
var (
	godotenvLoad     = godotenv.Load
	envconfigProcess = envconfig.Process
)

// Read reads configuration from environment variables.
// It assumes that an '.env' file is present at current path.
func Read() (*Config, error) {
	if err := godotenvLoad(); err != nil {
		return nil, errors.Wrap(err, "loading env vars from .env file")
	}
	config := new(Config)
	if err := envconfigProcess("", config); err != nil {
		return nil, errors.Wrap(err, "processing env vars")
	}
	return config, nil
}

// ReadFromEnvFile reads configuration from the specified environment file.
func ReadFromEnvFile(envFilePath string) (*Config, error) {
	if err := godotenvLoad(envFilePath); err != nil {
		return nil, errors.Wrapf(err, "loading env vars from %s", envFilePath)
	}
	config := new(Config)
	if err := envconfigProcess("", config); err != nil {
		return nil, errors.Wrap(err, "processing env vars")
	}
	return config, nil
}
</code></pre></div></div>

<ol>
  <li><code class="language-plaintext highlighter-rouge">appcfg/config_test.go</code></li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package appcfg

import (
	"errors"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestRead(t *testing.T) {
	testCases := []struct {
		name                   string
		mockedGodotenvLoad     func(filenames ...string) (err error)
		mockedEnvconfigProcess func(prefix string, spec interface{}) error
		expectedError          error
	}{
		{
			name: "happy path",
			mockedGodotenvLoad: func(filenames ...string) (err error) {
				return nil
			},
			mockedEnvconfigProcess: func(prefix string, spec interface{}) error {
				return nil
			},
		},
		{
			name: "error loading env vars",
			mockedGodotenvLoad: func(filenames ...string) (err error) {
				return errors.New("random error")
			},
			expectedError: errors.New("loading env vars from .env file: random error"),
		},
		{
			name: "error processing env vars",
			mockedGodotenvLoad: func(filenames ...string) (err error) {
				return nil
			},
			mockedEnvconfigProcess: func(prefix string, spec interface{}) error {
				return errors.New("random error")
			},
			expectedError: errors.New("processing env vars: random error"),
		},
	}
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			godotenvLoad = tc.mockedGodotenvLoad
			envconfigProcess = tc.mockedEnvconfigProcess
			config, err := Read()
			if err != nil {
				if tc.expectedError == nil {
					t.Fatalf("expected no error, got %v", err)
				}
				require.Nil(t, config)
				require.Equal(t, tc.expectedError.Error(), err.Error())
			} else {
				if tc.expectedError != nil {
					t.Fatalf("expected error, got nil")
				}
				require.NotNil(t, config)
			}
		})
	}
}

func TestReadFromEnvFile(t *testing.T) {
	testCases := []struct {
		name                   string
		mockedGodotenvLoad     func(filenames ...string) (err error)
		mockedEnvconfigProcess func(prefix string, spec interface{}) error
		expectedError          error
	}{
		{
			name: "happy path",
			mockedGodotenvLoad: func(filenames ...string) (err error) {
				return nil
			},
			mockedEnvconfigProcess: func(prefix string, spec interface{}) error {
				return nil
			},
		},
		{
			name: "error loading env vars",
			mockedGodotenvLoad: func(filenames ...string) (err error) {
				return errors.New("random error")
			},
			expectedError: errors.New("loading env vars from path/to/.env: random error"),
		},
		{
			name: "error processing env vars",
			mockedGodotenvLoad: func(filenames ...string) (err error) {
				return nil
			},
			mockedEnvconfigProcess: func(prefix string, spec interface{}) error {
				return errors.New("random error")
			},
			expectedError: errors.New("processing env vars: random error"),
		},
	}
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			godotenvLoad = tc.mockedGodotenvLoad
			envconfigProcess = tc.mockedEnvconfigProcess
			config, err := ReadFromEnvFile("path/to/.env")
			if err != nil {
				if tc.expectedError == nil {
					t.Fatalf("expected no error, got %v", err)
				}
				require.Nil(t, config)
				require.Equal(t, tc.expectedError.Error(), err.Error())
			} else {
				if tc.expectedError != nil {
					t.Fatalf("expected error, got nil")
				}
				require.NotNil(t, config)
			}
		})
	}
}

</code></pre></div></div>

<h2 id="using-it-in-your-application">using it in your application</h2>

<ol>
  <li>reading configuration from <code class="language-plaintext highlighter-rouge">.env</code> file</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package main

import (
	"fmt"
	"os"

	"github.com/tiagomelo/go-project-config/appcfg"
)

func main() {
	cfg, err := appcfg.Read()
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	fmt.Printf("cfg: %+v\n", cfg)
}
</code></pre></div></div>

<ol>
  <li>reading configuration from a given env file</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package main

import (
	"fmt"
	"os"

	"github.com/tiagomelo/go-project-config/appcfg"
)

func main() {
	cfg, err := appcfg.ReadFromEnvFile(".env-sample")
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	fmt.Printf("cfg: %+v\n", cfg)
}
</code></pre></div></div>
