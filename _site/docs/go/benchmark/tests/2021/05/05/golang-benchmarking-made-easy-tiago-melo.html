<p><img src="/assets/images/2021-05-05-5f92c664-5beb-40ad-ad86-344b581c3d84/2021-05-05-banner.png" alt="Golang: benchmarking made easy" /></p>

<p>Benchmarking your application is often a good idea when it comes for fine tuning its performance.</p>

<p>The <a href="https://golang.org/">Golang</a> <a href="http://golang.org/pkg/testing/">testing</a> package contains a benchmarking facility that can be used to examine the performance of your <a href="https://golang.org/">Golang</a> code. In this article we’ll see how to write simple benchmark tests that are able to provide us good insights about a given algorithmic solution.</p>

<h2 id="the-good-old-fibonacci-number-calculation">The good old Fibonacci number calculation</h2>

<p><a href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci number</a> is a classic numerical series where each subsequent number is the sum of the previous two numbers: 1 1 2 3 5 8 13…</p>

<p>Let’s explore two different implementations: recursive and sequential. We’ll write both unit and benchmark tests for each approach and then we’ll be able to compare them.</p>

<h3 id="recursive-approach">Recursive approach</h3>

<p>When you look at the <a href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci algorithm</a>, it seems to be very straightforward to implement in nearly any programming language. And probably the first approach to solve it is to use <a href="https://en.wikipedia.org/wiki/Recursion_(computer_science)">recursion</a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package fibo

func RecursiveFibonacci(n uint) uint {
    if n &lt;= 1 {
        return n
    }
    return RecursiveFibonacci(n-1) + RecursiveFibonacci(n-2)

}

</code></pre></div></div>

<p>Each iteration in the series discards the previous results and then re-calculates the intermediate steps for each subsequent iteration.</p>

<p>Let’s add some unit tests:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package fibo

import "testing"

func TestRecursiveFibonacci(t *testing.T) {
    data := []struct {
        n    uint
        want uint
    }{
        {0, 0},
        {1, 1},
        {2, 1},
        {3, 2},
        {4, 3},
        {5, 5},
        {6, 8},
        {10, 55},
        {42, 267914296},
    }
    for _, d := range data {
        if got := RecursiveFibonacci(d.n); got != d.want {
            t.Errorf("got: %d, want: %d", got, d.want)
        }
    }
}

</code></pre></div></div>

<p>It works:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tiago:~/develop/go/fibonacci/fibo$ go test -run TestRecursiveFibonacci
PASS
ok  	bitbucket.org/tiagoharris/fibonacci/fibo	1.875s

</code></pre></div></div>

<h3 id="sequential-approach">Sequential approach</h3>

<p>This alternative implementation removes the recursion and instead uses a simple for loop and a couple of variables. If you think about it, the algorithm is nothing but a sum of N numbers. We start from 0 and 1 and we will start adding subsequent sums:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package fibo

func SequentialFibonacci(n uint) uint {
    if n &lt;= 1 {
        return uint(n)
    }
    var n2, n1 uint = 0, 1
    for i := uint(2); i &lt; n; i++ {
        n2, n1 = n1, n1+n2
    }
    return n2 + n1
}

</code></pre></div></div>

<p>Let’s add some unit tests:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func TestSequentialFibonacci(t *testing.T) {
    data := []struct {
        n    uint
        want uint
    }{
        {0, 0},
        {1, 1},
        {2, 1},
        {3, 2},
        {4, 3},
        {5, 5},
        {6, 8},
        {10, 55},
        {42, 267914296},
    }
    for _, d := range data {
        if got := SequentialFibonacci(d.n); got != d.want {
            t.Errorf("got: %d, want: %d", got, d.want)
        }
    }
}

</code></pre></div></div>

<p>It also works:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tiago:~/develop/go/fibonacci/fibo$ go test -run TestSequentialFibonacci
PASS
ok  	bitbucket.org/tiagoharris/fibonacci/fibo	0.631s

</code></pre></div></div>

<p>Notice that we’ve got a considerable performance improvement here; 0.631s versus 1.875s.</p>

<h2 id="benchmarking">Benchmarking</h2>

<p>In order to measure performance, we could measure execution time and display it with some print statements, of course. But <a href="http://golang.org">Golang</a> offers a very sophisticated tooling for benchmarking, and it’s fairly simple to use.</p>

<p>Writing a benchmark is very similar to writing a test as they share the infrastructure from the testing package. Some of the key differences are:</p>

<ul>
  <li>Benchmark functions start with ‘ <em>Benchmark</em>’, not ‘ <em>Test</em>’;</li>
  <li>Benchmark functions are run several times by the testing package. The value of ‘b.N’ will increase each time until the benchmark runner is satisfied with the stability of the benchmark;</li>
  <li>Each benchmark must execute the code under test b.N times. Thus, a ‘for’ loop will be present in every benchmark function.</li>
</ul>

<p>Our final <em>fibo_test.go</em> file will contain both unit and benchmark tests:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package fibo

import (
    "testing"
)

func BenchmarkTestRecursiveFibonacci_10(b *testing.B) {
    for i := 0; i &lt; b.N; i++ {
        RecursiveFibonacci(10)
    }
}

func BenchmarkTestRecursiveFibonacci_20(b *testing.B) {
    for i := 0; i &lt; b.N; i++ {
        RecursiveFibonacci(20)
    }
}

func BenchmarkTestSequentialFibonacci_10(b *testing.B) {
    for i := 0; i &lt; b.N; i++ {
        SequentialFibonacci(10)
    }
}

func BenchmarkTestSequentialFibonacci_20(b *testing.B) {
    for i := 0; i &lt; b.N; i++ {
        SequentialFibonacci(20)
    }
}

func TestRecursiveFibonacci(t *testing.T) {
    data := []struct {
        n    uint
        want uint
    }{
        {0, 0},
        {1, 1},
        {2, 1},
        {3, 2},
        {4, 3},
        {5, 5},
        {6, 8},
        {10, 55},
        {42, 267914296},
    }
    for _, d := range data {
        if got := RecursiveFibonacci(d.n); got != d.want {
            t.Errorf("got: %d, want: %d", got, d.want)
        }
    }
}

func TestSequentialFibonacci(t *testing.T) {
    data := []struct {
        n    uint
        want uint
    }{
        {0, 0},
        {1, 1},
        {2, 1},
        {3, 2},
        {4, 3},
        {5, 5},
        {6, 8},
        {10, 55},
        {42, 267914296},
    }
    for _, d := range data {
        if got := SequentialFibonacci(d.n); got != d.want {
            t.Errorf("got: %d, want: %d", got, d.want)
        }
    }
}

</code></pre></div></div>

<p>We’ll benchmark both recursive and sequential approaches by calculating the sequence for 10 and 20.</p>

<p>With benchmark tests in place, all we need to do is to invoke it via “go test -bench=.”. By default, it runs using all the CPUs available. You can change like this: “go test -cpu=4 -bench=.”.</p>

<p>My machine has 8 CPUs, as we can see by running <a href="https://htop.dev/">htop</a>:</p>

<p><img src="/assets/images/2021-05-05-5f92c664-5beb-40ad-ad86-344b581c3d84/1620223757682.png" alt="No alt text provided for this image" /></p>

<p>Lets run it:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tiago:~/develop/go/fibonacci/fibo$ go test -bench=.
goos: darwin
goarch: amd64
pkg: bitbucket.org/tiagoharris/fibonacci/fibo
cpu: Intel(R) Core(TM) i7-7820HQ CPU @ 2.90GHz
BenchmarkTestRecursiveFibonacci_10-8      3534949        335.2 ns/op
BenchmarkTestRecursiveFibonacci_20-8        28592      41587 ns/op
BenchmarkTestSequentialFibonacci_10-8    372993714          3.221 ns/op
BenchmarkTestSequentialFibonacci_20-8    193414836          6.175 ns/op
PASS
ok   bitbucket.org/tiagoharris/fibonacci/fibo 8.406s

</code></pre></div></div>

<p>The output format is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Benchmark&lt;test-name&gt;-&lt;number-of-cpus&gt; number of executions speed of each operation

</code></pre></div></div>

<p>Now we can have a better idea of how the sequential approach is way more efficient than the recursive one:</p>

<ul>
  <li><strong>BenchmarkTestRecursiveFibonacci10-8</strong> was executed 3,534.949 times with a speed of 335.2 ns/op, while <strong>BenchmarkTestSequentialFibonacci10-8</strong> was executed 372,993.714 times with a speed of 3.221 ns/op;</li>
  <li><strong>BenchmarkTestRecursiveFibonacci20-8</strong> was executed 28,592 times with a speed of 41730 ns/op, while <strong>BenchmarkTestSequentialFibonacci20-8</strong> was executed 193,414.836 times with a speed of 6.175 ns/op.</li>
</ul>

<h3 id="plotting-graphics">Plotting graphics</h3>

<p>I’m a huge fan of <a href="http://www.gnuplot.info/">gnuplot</a>. I’ve even written an <a href="https://www.linkedin.com/pulse/bash-how-plot-line-graph-gnuplot-5-from-file-json-lines-tiago-melo/">article</a> showing how it can be useful.</p>

<p>This is the <a href="http://www.gnuplot.info/">gnuplot</a> file that will be used to plot a <a href="http://gnuplot.sourceforge.net/docs_4.2/node241.html">box graphic</a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##
# gnuplot script to generate a performance graphic.
#
# it expects the following parameters:
#
# file_path - path to the file from which the data will be read
# graphic_file_name - the graphic file name to be saved
# y_label - the desired label for y axis
# y_range_min - minimum range for values in y axis
# y_range_max - maximum range for values in y axis
# column_1 - the first column to be used in plot command
# column_2 - the second column to be used in plot command
#
# Author: Tiago Melo (tiagoharris@gmail.com)
##

# graphic will be saved as 800x600 png image file
set terminal png

# allows grid lines to be drawn on the plot
set grid

# setting the graphic file name to be saved
set output graphic_file_name

# the graphic's main title
set title "performance comparison"

# since the input file is a CSV file, we need to tell gnuplot that data fields are separated by comma
set datafile separator ","

# disable key box
set key off

# label for y axis
set ylabel y_label

# range for values in y axis
set yrange[y_range_min:y_range_max]

# to avoid displaying large numbers in exponential format
set format y "%.0f"

# vertical label for x values
set xtics rotate

# set boxplots
set style fill solid
set boxwidth 0.5

# plot graphic for each line of input file
plot for [i=0:*] file_path every ::i::i using column_1:column_2:xtic(2) with boxes

</code></pre></div></div>

<p>This is the <em>benchmark</em> target in our <a href="https://en.wikipedia.org/wiki/Make_(software)">Makefile</a> that runs the benchmark tests and plot graphics for both number of operations and speed of each operation, so we can easily compare them:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>benchmark:
    @ cd fibo ; \
    go test -bench=. | tee ../graphic/out.dat ; \
    awk '/Benchmark/{count ++; gsub(/BenchmarkTest/,""); printf("%d,%s,%s,%s\n",count,$$1,$$2,$$3)}' ../graphic/out.dat &gt; ../graphic/final.dat ; \
    gnuplot -e "file_path='../graphic/final.dat'" -e "graphic_file_name='../graphic/operations.png'" -e "y_label='number of operations'" -e "y_range_min='000000000''" -e "y_range_max='400000000'" -e "column_1=1" -e "column_2=3" ../graphic/performance.gp ; \
    gnuplot -e "file_path='../graphic/final.dat'" -e "graphic_file_name='../graphic/time_operations.png'" -e "y_label='each operation in nanoseconds'" -e "y_range_min='000''" -e "y_range_max='45000'" -e "column_1=1" -e "column_2=4" ../graphic/performance.gp ; \
    rm -f ../graphic/out.dat ../graphic/final.dat ; \

echo "'graphic/operations.png' and 'graphic/time_operations.png' graphics were generated."

</code></pre></div></div>

<p>First, runs the benchmark tests using a <a href="https://en.wikipedia.org/wiki/Pipeline_(Unix)">pipe</a> with <a href="https://en.wikipedia.org/wiki/Tee_(command)">tee</a> command, which makes it possible to both display the output in the terminal &amp; save it to a file.</p>

<p>Then, we use <a href="https://en.wikipedia.org/wiki/AWK">awk</a> command to parse our file into a <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> format that will be used to plot the graphics. It looks like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1,RecursiveFibonacci10-8,3521120,341.8
2,RecursiveFibonacci20-8,3524374,342.7
3,SequentialFibonacci10-8,366928228,3.278
4,SequentialFibonacci20-8,365811716,3.302

</code></pre></div></div>

<p>Next, we call <a href="http://www.gnuplot.info/">gnuplot</a> two times: 1) generate graphic for number of executions 2) generate graphic for speed of each operation.</p>

<p>Let’s run it:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tiago:~/develop/go/fibonacci$ make benchmark

goos: darwin

goarch: amd64

pkg: bitbucket.org/tiagoharris/fibonacci/fibo

cpu: Intel(R) Core(TM) i7-7820HQ CPU @ 2.90GHz

BenchmarkTestRecursiveFibonacci10-8    	 3521120	       341.8 ns/op

BenchmarkTestRecursiveFibonacci20-8    	 3524374	       342.7 ns/op

BenchmarkTestSequentialFibonacci10-8   	366928228	         3.278 ns/op

BenchmarkTestSequentialFibonacci20-8   	365811716	         3.302 ns/op

PASS

ok  	bitbucket.org/tiagoharris/fibonacci/fibo	8.519s

'graphic/operations.png' and 'graphic/time_operations.png' graphics were generated.

</code></pre></div></div>

<p>Awesome.</p>

<p><strong>Number of operations:</strong></p>

<p><img src="/assets/images/2021-05-05-5f92c664-5beb-40ad-ad86-344b581c3d84/1620463994125.png" alt="No alt text provided for this image" /></p>

<p><strong>Speed of each operation:</strong></p>

<p><img src="/assets/images/2021-05-05-5f92c664-5beb-40ad-ad86-344b581c3d84/1620464031301.png" alt="No alt text provided for this image" /></p>

<p>Pretty cool, isn’t it?</p>

<h2 id="bonus-calculation-of-large-fibonacci-numbers">Bonus: calculation of large Fibonacci numbers</h2>

<p>The first idea that comes to my mind would be to use 128-bit integer variable. Unfortunately, Go does not have one (yet). But even then, there is one of the <a href="https://en.wikipedia.org/wiki/Fibonacci">Fibonacci</a> numbers that will not fit into 128-bit integer and we would need 256-bit integer and so on. Fortunately, Go has a package called <a href="https://golang.org/pkg/math/big/">math/big</a> and its <a href="https://golang.org/pkg/math/big/#Int">Int</a> type that will be very handy in this implementation:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func SequentialFibonacciBig(n uint) *big.Int {
    if n &lt;= 1 {
        return big.NewInt(int64(n))
    }

    var n2, n1 = big.NewInt(0), big.NewInt(1)

    for i := uint(1); i &lt; n; i++ {
        n2.Add(n2, n1)
        n1, n2 = n2, n1
    }

    return n1
}

</code></pre></div></div>

<p>To test it, here’s our <em>main.go</em> that accepts the desired number as a parameter:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package main

import (
    "flag"
    "fmt"

    "bitbucket.org/tiagoharris/fibonacci/fibo"
)

func main() {
    var n uint64
    flag.Uint64Var(&amp;n, "n", 0, "n")
    flag.Parse()

    fmt.Printf("%d: %d\n", n, fibo.SequentialFibonacciBig(uint(n)))
}

</code></pre></div></div>

<p>And here’s our target in <a href="https://en.wikipedia.org/wiki/Make_(software)">Makefile</a> to run it:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## build: build app's binary
build:
    @ go build -a -installsuffix cgo -o main .

## run: run the app
run: build
    @ if [ -z "$(N)" ]; then echo &gt;&amp;2 please set the number via the variable N; exit 2; fi
    @ ./main -n $(N)

</code></pre></div></div>

<p>Let’s run it for, say, 200:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tiago:~/develop/go/fibonacci$ make run N=200

200: 280571172992510140037611932413038677189525

</code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>

<p>In this article we learned how to use <a href="https://golang.org/">Golang</a> <a href="http://golang.org/pkg/testing/">testing</a> benchmark utility and how to use <a href="http://www.gnuplot.info/">gnuplot</a> to plot graphics for a better comparison.</p>

<h2 id="download-the-source">Download the source</h2>

<p>Here: <a href="https://bitbucket.org/tiagoharris/fibonacci/src/master/">https://bitbucket.org/tiagoharris/fibonacci/src/master/</a></p>
