<p><img src="/assets/images/2019-12-24-cfacf19e-1d43-48b8-820e-d4165f7a5c17/2019-12-24-banner.png" alt="Go: how to connect to a CloudSQL instance (MySQL) over SSL" /></p>

<p>If you read my <a href="https://www.linkedin.com/pulse/tale-data-migration-moving-195m-records-from-aws-gcp-using-tiago-melo/">previous article</a>, you’ve noticed that I connect to a <a href="https://cloud.google.com/sql/">CloudSQL</a> instance (running <a href="https://www.linkedin.com/redir/general-malware-page?url=https%3A%2F%2Fwww%2emysql%2ecom%2F">MySQL</a>) to load some <a href="https://pt.wikipedia.org/wiki/Comma-separated_values">CSV</a> files into tables.</p>

<p>What if that instance, in particular, is configured to accept only secure connections ( <a href="https://en.wikipedia.org/wiki/SSL">SSL</a>)?</p>

<p><img src="/assets/images/2019-12-24-cfacf19e-1d43-48b8-820e-d4165f7a5c17/1577201313919.png" alt="No alt text provided for this image" /></p>

<p>We could connect to it using the MySQL client, after configuring <a href="https://cloud.google.com/sql/docs/mysql/sql-proxy">cloud_sql_proxy</a>, like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql -u &lt;USER&gt; -p -D &lt;DATABASE&gt; -h &lt;HOST&gt; --ssl-ca=&lt;PATH/TO/server-ca.pem&gt; --ssl-cert=&lt;PATH/TO/client-cert.pem&gt; --ssl-key=&lt;PATH/TO/client-key.pem&gt;

</code></pre></div></div>

<p>In this article, we’ll see how to do the same in a <a href="https://golang.org/">Go</a> script.</p>

<h2 id="the-code">The code</h2>

<p>This is our file structure:</p>

<p><img src="/assets/images/2019-12-24-cfacf19e-1d43-48b8-820e-d4165f7a5c17/1577202572133.png" alt="No alt text provided for this image" /></p>

<ul>
  <li><em>ssl_client_certs:</em> here we store the three <em>.pem</em> files needed to connect over <a href="https://en.wikipedia.org/wiki/SSL">SSL</a>: <em>server-ca.pem</em>, <em>client-cert.pem</em> and <em>client-key.pem;</em></li>
  <li><em>ping_database.json</em>: this is the configuration file used in order to avoid hardcoded values in our source code;</li>
  <li><em>ping_database.go</em>: this is the <a href="https://golang.org/">Go</a> script that will connect to our <a href="https://cloud.google.com/sql/">CloudSQL</a> instance and try to <a href="https://en.wikipedia.org/wiki/Ping_(networking_utility)">ping</a> it.</li>
</ul>

<h3 id="configuration-file">Configuration file</h3>

<p><em>ping_database.json</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  "db": {
    "user": "&lt;USER&gt;",
    "pass": "&lt;PASSWORD&gt;",
    "schema": "&lt;SCHEMA&gt;",
    "port": "&lt;PORT&gt;",
    "host": "&lt;HOST&gt;",
    "timeout": "5s",
    "certs": {
      "clientCert": "&lt;PATH/TO/client-cert.pem&gt;",
      "clientKey": "&lt;PATH/TO/client-key.pem",
      "serverCa": "&lt;PATH/TO/server-ca.pem",
      "serverName": "&lt;PROJECT&gt;:&lt;INSTANCE_NAME&gt;"
    }
  }
}

</code></pre></div></div>

<h3 id="go-script">Go script</h3>

<p><em>ping_database.go</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
	This script shows how to connect to a CloudSQL instance over SSL.

	It reads json configuration filed named 'ping_database.json'.

	author: Tiago Melo (tiagoharris@gmail.com)
*/
package main

import (
	"crypto/tls"
	"crypto/x509"
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/go-sql-driver/mysql"
	"io/ioutil"
	"os"
)

type Certs struct {
	ClientCert string `json: "clientCert"`
	ClientKey  string `json: "clientKey"`
	ServerCa   string `json: "serverCa"`
	ServerName string `json: "serverName"`
}

type Db struct {
	User    string `json: "user"`
	Pass    string `json: "pass"`
	Schema  string `json: "schema"`
	Port    string `json: "port"`
	Host    string `json: "host"`
	Timeout string `json: "timeout"`
	Certs   Certs  `json: "certs"`
}

type Config struct {
	Db Db `json: "db"`
}

var config = Config{}
var configJsonFileName = "ping_database.json"

func checkError(message string, err error) {
	if err != nil {
		fmt.Fprintf(os.Stderr, "%v %v\n", message, err)
		os.Exit(1)
	}
}

func readConfiguration() {
	file, err := ioutil.ReadFile(configJsonFileName)

	checkError(fmt.Sprintf("Error reading file %s: ", configJsonFileName), err)

	err = json.Unmarshal([]byte(file), &amp;config)

	checkError(fmt.Sprintf("File %s is not a valid JSON: ", configJsonFileName), err)
}

// To connect to a MySQL instance over SSL, three files are required:
// server-ca.pem, client-cert.pem and client-key.pem
//
// This function creates a TLS config under the name of 'custom'
func setupTLSConfig() {
	rootCertPool := x509.NewCertPool()
	pem, err := ioutil.ReadFile(config.Db.Certs.ServerCa)
	if err != nil {
		checkError(fmt.Sprintf("Failed to append PEM file %s: ", config.Db.Certs.ServerCa), err)
	}
	if ok := rootCertPool.AppendCertsFromPEM(pem); !ok {
		checkError(fmt.Sprintf("Failed to append PEM file %s: ", config.Db.Certs.ServerCa), errors.New("call to 'rootCertPool.AppendCertsFromPEM' failed"))
	}
	clientCert := make([]tls.Certificate, 0, 1)
	certs, err := tls.LoadX509KeyPair(config.Db.Certs.ClientCert, config.Db.Certs.ClientKey)
	if err != nil {
		checkError(fmt.Sprintf("Failed to load key par %s and %s: ", config.Db.Certs.ClientCert, config.Db.Certs.ClientKey), err)
	}
	clientCert = append(clientCert, certs)
	mysql.RegisterTLSConfig("custom", &amp;tls.Config{
		RootCAs:      rootCertPool,
		Certificates: clientCert,
		ServerName:   config.Db.Certs.ServerName,
	})
}

func ping() {
	setupTLSConfig()

	fmt.Printf("Pinging database host %s... ", config.Db.Host)

	// Here we pass the TLS config created ('custom') and a timeout
	db, err := sql.Open("mysql", fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?tls=custom&amp;timeout=%s", config.Db.User, config.Db.Pass, config.Db.Host, config.Db.Port, config.Db.Schema, config.Db.Timeout))

	defer db.Close()

	checkError("Error getting a handle to the database:", err)

	// Once that we get the handle, let's try to ping the database
	err = db.Ping()

	checkError("Error establishing a connection to the database:", err)

	fmt.Println("ok!")
}

func main() {
	readConfiguration()
	ping()
}

</code></pre></div></div>

<h2 id="running-it">Running it</h2>

<p>In order to successfully connect to the CloudSQL instance, remember to:</p>

<p>1) get <em>server-ca.pem</em>, <em>client-cert.pem</em> and <em>client-key.pem</em> for the desired instance</p>

<p><img src="/assets/images/2019-12-24-cfacf19e-1d43-48b8-820e-d4165f7a5c17/1577203635138.png" alt="No alt text provided for this image" /></p>

<p>2) authorize your IP address:</p>

<p><img src="/assets/images/2019-12-24-cfacf19e-1d43-48b8-820e-d4165f7a5c17/1577203800982.png" alt="No alt text provided for this image" /></p>

<p>With everything in place, you should be able to ping the database:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ go run ping_database.go

Pinging database host &lt;DATABASE_HOST&gt;... ok!

</code></pre></div></div>

<h2 id="download-the-source">Download the source</h2>

<p>Here: <a href="https://bitbucket.org/tiagoharris/cloudsql_mysql_ssl_tutorial/src/master/">https://bitbucket.org/tiagoharris/cloudsql_mysql_ssl_tutorial/src/master/</a></p>
