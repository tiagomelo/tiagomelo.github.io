<p><img src="/assets/images/2019-11-05-41fcf0f8-7d0c-494a-87f9-89f30deb1c0f/2019-11-05-banner.png" alt="Go: database migrations made easy - an example using MySQL" /></p>

<p>In my <a href="https://www.linkedin.com/pulse/java-database-versioning-liquibase-tiago-melo/">article</a> about database migrations, I’ve shown how database migrations are done on <a href="https://rubyonrails.org/">Ruby On Rails</a> and brought it to the <a href="https://www.java.com/">Java</a> world. It’s time to see how it works in <a href="https://golang.org/">Go</a>.</p>

<h2 id="meet-migrate">Meet Migrate</h2>

<p>I’ve been actively developing applications using <a href="https://golang.org/">Go</a>, and I needed to find a good solution for database migrations.</p>

<p><a href="https://github.com/golang-migrate/migrate">Migrate</a> is a robust and simple tool to use for that. It can be used as <a href="https://github.com/golang-migrate/migrate#cli-usage">CLI</a> or as <a href="https://github.com/golang-migrate/migrate#use-in-your-go-project">library</a></p>

<p>In this article, we’ll focus on <a href="https://github.com/golang-migrate/migrate#cli-usage">CLI</a> usage.</p>

<h3 id="main-commands">Main commands</h3>

<p>We’ll explore each of the following <a href="https://github.com/golang-migrate/migrate/tree/master/cmd/migrate">CLI commands</a>:</p>

<p><img src="/assets/images/2019-11-05-41fcf0f8-7d0c-494a-87f9-89f30deb1c0f/1572872382038.png" alt="No alt text provided for this image" /></p>

<h3 id="migration-files">Migration files</h3>

<p>A single logical migration is represented as two separate migration files, one to migrate “up” to the specified version from the previous version, and a second to migrate back “down” to the previous version.</p>

<p>The ordering and direction of the migration files are determined by the filenames used for them. The <em>migrate</em> command expects the filenames of migrations to have the format:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{version}_{title}.up.{extension}
{version}_{title}.down.{extension}

</code></pre></div></div>

<p>The <em>title</em> of each migration is unused and is only for readability. Similarly, the extension of the migration files is not checked by the library and should be an appropriate format for the database in use (.sql for SQL variants, for instance).</p>

<p>Versions of migrations may be represented as any 64-bit unsigned integer. All migrations are applied upward in order of increasing version number, and downward by decreasing version number.</p>

<p>Common versioning schemes include incrementing integers:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1_initialize_schema.down.sql
1_initialize_schema.up.sql
2_add_table.down.sql
2_add_table.up.sql

...

</code></pre></div></div>

<p>Or timestamps at an appropriate resolution:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1500360784_initialize_schema.down.sql
1500360784_initialize_schema.up.sql
1500445949_add_table.down.sql
1500445949_add_table.up.sql

...

</code></pre></div></div>

<p>But any scheme resulting in distinct, incrementing integers as versions is valid.</p>

<h2 id="the-domain-model">The domain model</h2>

<p>This is our initial domain model that will be evolved during this article:</p>

<p><img src="/assets/images/2019-11-05-41fcf0f8-7d0c-494a-87f9-89f30deb1c0f/1572819554276.png" alt="No alt text provided for this image" /></p>

<p>The ‘ <em>Library</em>’ table has a <a href="https://en.wikipedia.org/wiki/One-to-many_(data_model)">One To Many</a> relationship with ‘ <em>Book</em>’ table.</p>

<h2 id="the-go-application">The Go application</h2>

<p>This is our final directory structure:</p>

<p><img src="/assets/images/2019-11-05-41fcf0f8-7d0c-494a-87f9-89f30deb1c0f/1572960994439.png" alt="No alt text provided for this image" /></p>

<p>To ease the setup, I’m going to use <a href="https://docs.docker.com/compose/">docker-compose</a> to launch our <a href="https://www.linkedin.com/redir/general-malware-page?url=https%3A%2F%2Fwww%2emysql%2ecom%2F">MySQL</a> instance. I’m also using <a href="https://www.adminer.org/">Adminer</a>, which is a lightweight database management tool.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>version: '3'
services:
  db:
    image: mysql:5.7
    restart: always
    container_name: mysql_database
    ports:
      - "5432:3306"
    volumes:
      - data:/var/lib/mysql
    environment:
      - MYSQL_USER=tutorial
      - MYSQL_PASSWORD=tutorialpasswd
      - MYSQL_ROOT_PASSWORD=Mysql2019!
      - MYSQL_DATABASE=migrations_tutorial
      - MYSQL_HOST_NAME=mysql_db
    networks:
      - app-network

  adminer:
    image: adminer
    container_name: adminer
    ports:
      - 8080:8080
    networks:
      - app-network

volumes:
  data:
    driver: local

networks:
  app-network:
    driver: bridge

</code></pre></div></div>

<p>If you are new to <a href="https://www.docker.com/">Docker</a> and/or <a href="https://docs.docker.com/compose/">docker-compose</a>, whenever you want to use an image, you can visit <a href="https://hub.docker.com">Docker Hub</a> to check for available images.</p>

<p>Some details:</p>

<ul>
  <li><strong>db</strong>: I’m using <a href="https://hub.docker.com/_/mysql"><em>mysql:5.7</em></a> image. This container name is set to ‘mysql_database’, I’m exposing port 5432 to clients and it will be reachable by other containers by joining a custom network named ‘app-network’.</li>
  <li><strong>adminer</strong>: I’m using <a href="https://hub.docker.com/_/adminer">adminer</a> image. This container name is set to ‘adminer’, I’m exposing port 8080 to clients and it will be reachable by other containers by joining a custom network named ‘app-network’.</li>
  <li><strong>networks</strong>: I’m creating a custom network called ‘app-network’ of type ‘ <a href="https://www.docker.com/blog/understanding-docker-networking-drivers-use-cases/">bridge</a>’.</li>
</ul>

<p>This is our <a href="https://golang.org/">Go</a> script that connects to the database and displays all tables with their columns. It’ll be used to show the effects of migrations:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//  This Go script displays all tables in a given database
//  along with their respective columns.
//
//  author: Tiago Melo (tiagoharris@gmail.com)

package main

import (
	"database/sql"
	"fmt"
	_ "github.com/go-sql-driver/mysql"
	"log"
	"strings"
)

// helper function to handle errors
func checkError(message string, err error) {
	if err != nil {
		log.Fatal(message, err)
	}
}

func showTablesWithColumns() {
	// sql.Open does not return a connection. It just returns a handle to the database.
	// In a real world scenario, those db credentials could be environment variables and we could use a package like github.com/kelseyhightower/envconfig to read them.
	db, err := sql.Open("mysql", "root@tcp(127.0.0.1:5432)/migrations_tutorial")

	// A defer statement pushes a function call onto a list.
	// The list of saved calls is executed after the surrounding function returns.
	// Defer is commonly used to simplify functions that perform various clean-up actions.
	defer db.Close()

	checkError("Error getting a handle to the database", err)

	// Now it's time to validate the Data Source Name (DSN) to check if the connection
	// can be correctly established.
	err = db.Ping()

	checkError("Error establishing a connection to the database", err)

	showTablesQuery, err := db.Query("SHOW TABLES")

	defer showTablesQuery.Close()

	checkError("Error creating the query", err)

	for showTablesQuery.Next() {
		var tableName string

		// Get table name
		err = showTablesQuery.Scan(&amp;tableName)

		checkError("Error querying tables", err)

		selectQuery, err := db.Query(fmt.Sprintf("SELECT * FROM %s", tableName))

		defer selectQuery.Close()

		checkError("Error creating the query", err)

		// Get column names from the given table
		columns, err := selectQuery.Columns()
		if err != nil {
			checkError(fmt.Sprintf("Error getting columns from table %s", tableName), err)
		}

		fmt.Printf("table name: %s -- columns: %v\n", tableName, strings.Join(columns, ", "))
	}
}

func main() {
	showTablesWithColumns()
}

</code></pre></div></div>

<p>When it comes to <a href="https://golang.org/">Go</a> development, a common tool to use is our good old friend <a href="https://en.wikipedia.org/wiki/Make_(software)">Make</a>. This is the <a href="https://en.wikipedia.org/wiki/Makefile">Makefile</a> that I’ve written to facilitate issuing migration commands:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Author: Tiago Melo (tiagoharris@gmail.com)

# Version - this is optionally used on goto command
V?=

# Number of migrations - this is optionally used on up and down commands
N?=

# In a real world scenario, these environment variables
# would be injected by your build tool, like Drone for example (https://drone.io/)
MYSQL_USER ?= tutorial
MYSQL_PASSWORD ?= tutorialpasswd
MYSQL_HOST ?= 127.0.0.1
MYSQL_DATABASE ?= migrations_tutorial
MYSQL_PORT ?= 5432

MYSQL_DSN ?= $(MYSQL_USER):$(MYSQL_PASSWORD)@tcp($(MYSQL_HOST):$(MYSQL_PORT))/$(MYSQL_DATABASE)

local-db:
	@ docker-compose up -d

	@ until mysql --host=$(MYSQL_HOST) --port=$(MYSQL_PORT) --user=$(MYSQL_USER) -p$(MYSQL_PASSWORD) --protocol=tcp -e 'SELECT 1' &gt;/dev/null 2&gt;&amp;1 &amp;&amp; exit 0; do \
	  &gt;&amp;2 echo "MySQL is unavailable - sleeping"; \
	  sleep 5 ; \
	done

	@ echo "MySQL is up and running!"

migrate-setup:
	@if [ -z "$$(which migrate)" ]; then echo "Installing migrate command..."; go install -tags 'mysql' github.com/golang-migrate/migrate/v4/cmd/migrate; fi

migrate-up: migrate-setup
	@ migrate -database 'mysql://$(MYSQL_DSN)?multiStatements=true' -path migrations up $(N)

migrate-down: migrate-setup
	@ migrate -database 'mysql://$(MYSQL_DSN)?multiStatements=true' -path migrations down $(N)

migrate-to-version: migrate-setup
	@ migrate -database 'mysql://$(MYSQL_DSN)?multiStatements=true' -path migrations goto $(V)

drop-db: migrate-setup
	@ migrate -database 'mysql://$(MYSQL_DSN)?multiStatements=true' -path migrations drop

force-version: migrate-setup
	@ migrate -database 'mysql://$(MYSQL_DSN)?multiStatements=true' -path migrations force $(V)

migration-version: migrate-setup
	@ migrate -database 'mysql://$(MYSQL_DSN)?multiStatements=true' -path migrations version

build:
	@ go build inspect_database.go

run: build
	@ ./inspect_database

</code></pre></div></div>

<h2 id="its-showtime">It’s showtime!</h2>

<p>Let’s first set up our database:</p>

<p><img src="/assets/images/2019-11-05-41fcf0f8-7d0c-494a-87f9-89f30deb1c0f/1572960655495.png" alt="No alt text provided for this image" /></p>

<p>The <em>local-db</em> target invokes <em>docker-compose up -d</em> command and waits for <a href="https://www.linkedin.com/redir/general-malware-page?url=https%3A%2F%2Fwww%2emysql%2ecom%2F">MySQL</a> to be ready to accept connections.</p>

<p>Now let’s check if the containers were successfully created:</p>

<p><img src="/assets/images/2019-11-05-41fcf0f8-7d0c-494a-87f9-89f30deb1c0f/1572960813893.png" alt="No alt text provided for this image" /></p>

<p>Ok. And then we check that the volume ‘data’ was created as well:</p>

<p><img src="/assets/images/2019-11-05-41fcf0f8-7d0c-494a-87f9-89f30deb1c0f/1572960901197.png" alt="No alt text provided for this image" /></p>

<p>And then, if we run the app, since we don’t have any tables, there’s no output:</p>

<p><img src="/assets/images/2019-11-05-41fcf0f8-7d0c-494a-87f9-89f30deb1c0f/1572961156102.png" alt="No alt text provided for this image" /></p>

<h3 id="create-library-and-book-tables">Create Library and Book tables</h3>

<p>Let’s write the migrations and put them under <em>migrations</em> folder.</p>

<p><em>0001_create_library_table.up.sql</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE TABLE IF NOT EXISTS `library` (
	id INTEGER PRIMARY KEY AUTO_INCREMENT,
	name VARCHAR(100) NOT NULL UNIQUE
);

</code></pre></div></div>

<p><em>0001_create_library_table.down.sql</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DROP TABLE IF EXISTS `library`;

</code></pre></div></div>

<p><em>0002_create_book_table.up.sql</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE TABLE IF NOT EXISTS `book` (
	id INTEGER PRIMARY KEY AUTO_INCREMENT,
	title VARCHAR(100) NOT NULL UNIQUE,
	library_id INTEGER,
	FOREIGN KEY(library_id) REFERENCES library(id)
);

</code></pre></div></div>

<p><em>0002_create_book_table.down.sql</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DROP TABLE IF EXISTS `book`;

</code></pre></div></div>

<p>Now it’s time to run the pending migrations:</p>

<p><img src="/assets/images/2019-11-05-41fcf0f8-7d0c-494a-87f9-89f30deb1c0f/1572965626618.png" alt="No alt text provided for this image" /></p>

<p>Cool. Let’s run the app:</p>

<p><img src="/assets/images/2019-11-05-41fcf0f8-7d0c-494a-87f9-89f30deb1c0f/1572965689886.png" alt="No alt text provided for this image" /></p>

<p>The <em>schema_migrations</em> table is created by <a href="https://github.com/golang-migrate/migrate">Migrate</a> tool to keep track of migrations. We’ll see it in a minute.</p>

<p>Another way to check the recently created tables is through <a href="https://www.adminer.org/">Adminer</a>. Just point your browser to localhost:8080 and use the credentials defined in <em>docker-compose.yaml</em>:</p>

<p><img src="/assets/images/2019-11-05-41fcf0f8-7d0c-494a-87f9-89f30deb1c0f/1572965990587.png" alt="No alt text provided for this image" /></p>

<p><img src="/assets/images/2019-11-05-41fcf0f8-7d0c-494a-87f9-89f30deb1c0f/1572966007377.png" alt="No alt text provided for this image" /></p>

<h3 id="add-columns-to-book-table">Add columns to ‘Book’ table</h3>

<p>Now let’s add two columns: <em>isbn</em> and <em>publisher</em>, by adding the corresponding ‘up’ and ‘down’ migration files into <em>migrations</em> folder.</p>

<p><em>0003_add_isbn_and_publisher_to_book.up.sql</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BEGIN;

ALTER TABLE `book`

ADD COLUMN `isbn` varchar(13) NOT NULL,
ADD COLUMN `publisher` varchar(20) NOT NULL;

COMMIT;

</code></pre></div></div>

<p><em>0003_add_isbn_and_publisher_to_book.down.sql</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BEGIN;

ALTER TABLE `book` DROP COLUMN `isbn`;
ALTER TABLE `book` DROP COLUMN `publisher`;

COMMIT;

</code></pre></div></div>

<p>Note that this time we are using BEGIN and COMMIT to make those changes into a single transaction.</p>

<p>Let’s run the pending migrations:</p>

<p><img src="/assets/images/2019-11-05-41fcf0f8-7d0c-494a-87f9-89f30deb1c0f/1572966327214.png" alt="No alt text provided for this image" /></p>

<p>Now we should see the new columns when running the app:</p>

<p><img src="/assets/images/2019-11-05-41fcf0f8-7d0c-494a-87f9-89f30deb1c0f/1572966374804.png" alt="No alt text provided for this image" /></p>

<p>You could check that through <a href="https://www.adminer.org/">Adminer</a> if you want.</p>

<h3 id="drop-publisher-column-on-book-table">Drop ‘publisher’ column on ‘Book’ table</h3>

<p>What if ‘publisher’ column is not necessary anymore? Add the migration files into <em>migrations</em> folder.</p>

<p><em>0004_drop_publisher_on_book.up.sql</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALTER TABLE `book` DROP COLUMN `publisher`;

</code></pre></div></div>

<p><em>0004_drop_publisher_on_book.down.sql</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALTER TABLE `book` ADD COLUMN `publisher` varchar(20) NOT NULL;

</code></pre></div></div>

<p>Let’s run the pending migrations:</p>

<p><img src="/assets/images/2019-11-05-41fcf0f8-7d0c-494a-87f9-89f30deb1c0f/1572966606312.png" alt="No alt text provided for this image" /></p>

<p>Now we should see that ‘publisher’ is not on ‘Book’ table anymore when running the app:</p>

<p><img src="/assets/images/2019-11-05-41fcf0f8-7d0c-494a-87f9-89f30deb1c0f/1572966674269.png" alt="No alt text provided for this image" /></p>

<h2 id="playing-around">Playing around</h2>

<p>Now that we have all of the tables in place with the desired changes, it’s time to know some other options that we have.</p>

<p>Given that we have <strong>4 migrations</strong> (each one with the corresponding ‘up’ and ‘down’ files), let’s see how <em>schema_migrations</em> table looks like. Let’s connect to our <a href="https://www.linkedin.com/redir/general-malware-page?url=https%3A%2F%2Fwww%2emysql%2ecom%2F">MySQL</a> <a href="https://www.docker.com/">Docker</a> container:</p>

<p><img src="/assets/images/2019-11-05-41fcf0f8-7d0c-494a-87f9-89f30deb1c0f/1572967000884.png" alt="No alt text provided for this image" /></p>

<h3 id="print-current-migration-version">Print current migration version</h3>

<p><img src="/assets/images/2019-11-05-41fcf0f8-7d0c-494a-87f9-89f30deb1c0f/1572967116286.png" alt="No alt text provided for this image" /></p>

<h3 id="dropping-the-database">Dropping the database</h3>

<p><img src="/assets/images/2019-11-05-41fcf0f8-7d0c-494a-87f9-89f30deb1c0f/1572967214624.png" alt="No alt text provided for this image" /></p>

<h3 id="applying-n-up-migrations">Applying N up migrations</h3>

<p>Since we dropped the database above, let’s just create ‘Library’ and ‘Book’ tables. This can be accomplished by passing N=2:</p>

<p><img src="/assets/images/2019-11-05-41fcf0f8-7d0c-494a-87f9-89f30deb1c0f/1572967400577.png" alt="No alt text provided for this image" /></p>

<h3 id="applying-n-down-migrations">Applying N down migrations</h3>

<p>Let’s rollback migration #2 which creates ‘Book’ table. To do this, let’s pass N=1:</p>

<p><img src="/assets/images/2019-11-05-41fcf0f8-7d0c-494a-87f9-89f30deb1c0f/1572967529722.png" alt="No alt text provided for this image" /></p>

<h3 id="migrate-to-a-given-version">Migrate to a given version</h3>

<p>Right now we have only ‘Library’ table. What if we want to jump up to migration #3? Just pass V=3:</p>

<p><img src="/assets/images/2019-11-05-41fcf0f8-7d0c-494a-87f9-89f30deb1c0f/1572967760933.png" alt="No alt text provided for this image" /></p>

<h3 id="force-a-given-version">Force a given version</h3>

<p>This command sets the desired version but does not run the migration. This is useful when dealing with legacy databases.</p>

<p>For example: suppose that ‘Library’ and ‘Book’ tables already exist, and you want to use <a href="https://github.com/golang-migrate/migrate">Migrate</a> from now on. Let’s drop the database and create the tables manually:</p>

<p><img src="/assets/images/2019-11-05-41fcf0f8-7d0c-494a-87f9-89f30deb1c0f/1572968559599.png" alt="No alt text provided for this image" /></p>

<p>Ok. Now we want to tell to <a href="https://github.com/golang-migrate/migrate">Migrate</a> that the database is currently on version #2 (with ‘Library’ and ‘Book’ tables in place, but ‘Book’ does not have ‘isbn’ and ‘publisher’ columns):</p>

<p><img src="/assets/images/2019-11-05-41fcf0f8-7d0c-494a-87f9-89f30deb1c0f/1572968240079.png" alt="No alt text provided for this image" /></p>

<p>Let’s check the migration version - it will read from <em>schema_migrations</em> table:</p>

<p><img src="/assets/images/2019-11-05-41fcf0f8-7d0c-494a-87f9-89f30deb1c0f/1572968702731.png" alt="No alt text provided for this image" /></p>

<p>Now, if we ask to run all pending migrations, since we forced it to version #2, only migration files #3 and #4 will run:</p>

<p><img src="/assets/images/2019-11-05-41fcf0f8-7d0c-494a-87f9-89f30deb1c0f/1572968788499.png" alt="No alt text provided for this image" /></p>

<p>Now let’s check the tables by running the app:</p>

<p><img src="/assets/images/2019-11-05-41fcf0f8-7d0c-494a-87f9-89f30deb1c0f/1572968854312.png" alt="No alt text provided for this image" /></p>

<p>Cool, isn’t it?</p>

<h2 id="conclusion">Conclusion</h2>

<p>Versioning database changes is as important as versioning source code, and tools like <a href="https://github.com/golang-migrate/migrate">Migrate</a> makes it possible to do it in a safe and manageable way.</p>

<p>Through this simple example, we learned how we can easily evolve a database in a <a href="https://golang.org/">Go</a> application.</p>

<h2 id="download-the-source">Download the source</h2>

<p>Here: <a href="https://bitbucket.org/tiagoharris/migrations_tutorial/src/master/">https://bitbucket.org/tiagoharris/migrations_tutorial/src/master/</a></p>
