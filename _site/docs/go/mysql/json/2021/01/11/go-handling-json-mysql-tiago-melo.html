<p><img src="/assets/images/2021-01-11-0fbfe62b-8d26-4bb7-bf58-ee3443f64f45/2021-01-11-banner.jpeg" alt="Go: Handling JSON in MySQL" /></p>

<p>In this article, we’ll see how to read/write <a href="https://www.json.org/">JSON</a> data from/into a <a href="https://www.mysql.com/">MySQL</a> table.</p>

<h2 id="motivation">Motivation</h2>

<p>Sometimes you can find yourself in a situation where you’d like to use a hybrid approach: what if you could structure some parts of your database and leave others to be flexible?</p>

<p>Suppose we want to track the actions taken on a given website. We’ll create a table called “events” to hold that information:</p>

<p><img src="/assets/images/2021-01-11-0fbfe62b-8d26-4bb7-bf58-ee3443f64f45/1610296547706.png" alt="No alt text provided for this image" /></p>

<ul>
  <li><strong>id</strong>: PK that uniquely identifies the event;</li>
  <li><strong>name</strong>: event’s name;</li>
  <li><strong>properties</strong>: event’s properties;</li>
  <li><strong>browser</strong>: specification of the browser that visitors use to browse the website.</li>
</ul>

<p>The <a href="https://www.json.org/">JSON</a> datatype was introduced in <a href="https://www.mysql.com/">MySQL</a> 5.7. This is the <a href="https://en.wikipedia.org/wiki/Data_definition_language">DDL</a> for our table:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE TABLE events(
  id int auto_increment primary key,
  name varchar(255),
  properties json,
  browser json
);

</code></pre></div></div>

<p>If we were to manually insert records, we could do it like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>INSERT INTO events(event_name, properties, browser)
VALUES (
  'pageview',
   '{ "page": "/" }',
   '{ "name": "Safari", "os": "Mac", "resolution": { "x": 1920, "y": 1080 } }'
),
('pageview',
  '{ "page": "/contact" }',
  '{ "name": "Firefox", "os": "Windows", "resolution": { "x": 2560, "y": 1600 } }'
),
(
  'pageview',
  '{ "page": "/products" }',
  '{ "name": "Safari", "os": "Mac", "resolution": { "x": 1920, "y": 1080 } }'
),
(
  'purchase',
  '{ "amount": 200 }',
  '{ "name": "Firefox", "os": "Windows", "resolution": { "x": 1600, "y": 900 } }'
),
(
  'purchase',
  '{ "amount": 150 }',
  '{ "name": "Firefox", "os": "Windows", "resolution": { "x": 1280, "y": 800 } }'
),
(
  'purchase',
  '{ "amount": 500 }',
  '{ "name": "Chrome", "os": "Windows", "resolution": { "x": 1680, "y": 1050 } }'
);

</code></pre></div></div>

<p>To pull values out of the <a href="https://www.json.org/">JSON</a> columns, we use the column <a href="https://dev.mysql.com/doc/refman/5.7/en/json-search-functions.html#operator_json-column-path">path operator</a> ( <a href="https://dev.mysql.com/doc/refman/5.7/en/json-search-functions.html#operator_json-column-path">-&gt;</a>). Let’s play with browser’s name:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT id, browser-&gt;'$.name' browser
FROM events;

</code></pre></div></div>

<p>This query returns the following output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+----+-----------+
| id | browser   |
+----+-----------+
|  1 | "Safari"  |
|  2 | "Firefox" |
|  3 | "Safari"  |
|  4 | "Firefox" |
|  5 | "Firefox" |
|  6 | "Chrome"  |
+----+-----------+
6 rows in set (0.00 sec)

</code></pre></div></div>

<p>Notice that data in the browser column is surrounded by quote marks. To remove the quote marks, we use the <a href="https://dev.mysql.com/doc/refman/5.7/en/json-search-functions.html#operator_json-inline-path">inline path operator</a> ( <a href="https://dev.mysql.com/doc/refman/5.7/en/json-search-functions.html#operator_json-inline-path">-»</a>) like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT id, browser-&gt;&gt;'$.name' browser
FROM events;

</code></pre></div></div>

<p>As we can see in the following output, the quote marks were removed:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+----+---------+
| id | browser |
+----+---------+
|  1 | Safari  |
|  2 | Firefox |
|  3 | Safari  |
|  4 | Firefox |
|  5 | Firefox |
|  6 | Chrome  |
+----+---------+
6 rows in set (0.00 sec)

</code></pre></div></div>

<p>As you’ve imagined, we can use the path operator like any other field type. For example, to get the browser usage, we can use the following statement:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT browser-&gt;&gt;'$.name' browser, count(browser)
FROM events
GROUP BY browser-&gt;&gt;'$.name';

</code></pre></div></div>

<p>The output of the query is as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+---------+----------------+
| browser | count(browser) |
+---------+----------------+
| Safari  |              2 |
| Firefox |              3 |
| Chrome  |              1 |
+---------+----------------+
3 rows in set (0.02 sec)

</code></pre></div></div>

<h2 id="the-code">The code</h2>

<p>Now let’s see how we can work with these <a href="https://www.json.org/">JSON</a> fields in <a href="https://golang.org/">Go</a>, step by step.</p>

<p>First, let’s define the struct we’ll use to represent a record in “events” table:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type (
	StringInterfaceMap map[string]interface{}
	Event              struct {
		Id         int                `json:"id"`
		Name       string             `json:"name"`
		Properties StringInterfaceMap `json:"properties"`
		Browser    StringInterfaceMap `json:"browser"`
	}
)

</code></pre></div></div>

<p>Notice that in our “Event” struct, we defined both “Properties” and “Browser” as our <a href="https://golang.org/ref/spec#Type_identity">named type</a> “StringInferfaceMap”, which is map of string keys that can store pretty much any kind of information (int, string, other structs, and so on).</p>

<p>Next, let’s create some variables to hold the SQL queries we’ll use:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var (
	insertEventQuery = `INSERT INTO events(name, properties, browser) values (?, ?, ?)`
	selectEventByIdQuery = `SELECT * FROM events WHERE id = ?`
)

</code></pre></div></div>

<p>Now, the interesting part: how do we do to read the JSON columns? how do we persist them?</p>

<p>You’re right: we need a way of customizing the way that “properties” and “browser” JSON columns are read and written. We could write some helper functions to do the work, but it wouldn’t be a clean approach. What if we could use interfaces to come up with a cleaner design?</p>

<h3 id="the-read-operation">The read operation</h3>

<p><a href="https://golang.org/">Go</a> provides the <a href="https://golang.org/pkg/database/sql/#Scanner">Scanner</a> interface to do the data type conversion while scanning.</p>

<p>The signature of the <a href="https://golang.org/pkg/database/sql/#Scanner">Scanner</a> interface returns an error and not the converted value:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Scanner interface {
  Scan(src interface{}) error
}

</code></pre></div></div>

<p>Thus, the implementor of this interface should have a <a href="https://tour.golang.org/methods/4">pointer receiver</a> which will mutate its value upon successful conversion.</p>

<p>When implementing this interface, we need to convert the <a href="https://golang.org/pkg/builtin/#uint8">uint8</a> slice into a <a href="https://golang.org/pkg/builtin/#byte">byte</a> slice first, then we call <a href="https://golang.org/pkg/encoding/json/#Unmarshal">json.Unmarshal()</a> so we can convert it in map[string]interface{}. If the conversion is successful, we need to assign the converted value to the receiver “StringInterfaceMap”. Here’s our full implementation:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func (m *StringInterfaceMap) Scan(src interface{}) error {
	var source []byte
	_m := make(map[string]interface{})

	switch src.(type) {
	case []uint8:
		source = []byte(src.([]uint8))
	case nil:
		return nil
	default:
		return errors.New("incompatible type for StringInterfaceMap")
	}
	err := json.Unmarshal(source, &amp;_m)
	if err != nil {
		return err
	}
	*m = StringInterfaceMap(_m)
	return nil
}

</code></pre></div></div>

<p>Note that we are handling “null” values as well, as both columns are nullable. If that’s the case, it will be translated as an empty map.</p>

<h3 id="the-write-operation"><strong>The write operation</strong></h3>

<p>Like the <a href="https://golang.org/pkg/database/sql/#Scanner">Scanner</a> interface, <a href="https://golang.org/">Go</a> provides the <a href="https://golang.org/pkg/database/sql/driver/#Valuer">Valuer</a> interface that we need to implement to do the type conversion. We first check if the map is empty; if it’s the case, it will insert “null” into the respective column. Otherwise, it will call <a href="https://golang.org/pkg/encoding/json/#Marshal">json.Marshal()</a> and do the appropriate conversion:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func (m StringInterfaceMap) Value() (driver.Value, error) {
	if len(m) == 0 {
		return nil, nil
	}
	j, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	return driver.Value([]byte(j)), nil
}

</code></pre></div></div>

<p>This is the full source code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package main

import (
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"errors"
	"fmt"

	_ "github.com/go-sql-driver/mysql"
)

type (
	StringInterfaceMap map[string]interface{}
	Event              struct {
		Id         int                `json:"id"`
		Name       string             `json:"name"`
		Properties StringInterfaceMap `json:"properties"`
		Browser    StringInterfaceMap `json:"browser"`
	}
)

var (
	insertEventQuery     = `INSERT INTO events(name, properties, browser) values (?, ?, ?)`
	selectEventByIdQuery = `SELECT * FROM events WHERE id = ?`
)

func (m StringInterfaceMap) Value() (driver.Value, error) {
	if len(m) == 0 {
		return nil, nil
	}
	j, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	return driver.Value([]byte(j)), nil
}

func (m *StringInterfaceMap) Scan(src interface{}) error {
	var source []byte
	_m := make(map[string]interface{})

	switch src.(type) {
	case []uint8:
		source = []byte(src.([]uint8))
	case nil:
		return nil
	default:
		return errors.New("incompatible type for StringInterfaceMap")
	}
	err := json.Unmarshal(source, &amp;_m)
	if err != nil {
		return err
	}
	*m = StringInterfaceMap(_m)
	return nil
}

func insertEvent(db *sql.DB, event Event) (int64, error) {
	res, err := db.Exec(insertEventQuery, event.Name, event.Properties, event.Browser)
	if err != nil {
		return 0, err
	}
	lid, err := res.LastInsertId()
	if err != nil {
		return 0, err
	}
	return lid, nil
}

func selectEventById(db *sql.DB, id int64, event *Event) error {
	row := db.QueryRow(selectEventByIdQuery, id)
	err := row.Scan(&amp;event.Id, &amp;event.Name, &amp;event.Properties, &amp;event.Browser)
	if err != nil {
		return err
	}
	return nil
}

func getDNSString(dbName, dbUser, dbPassword, conn string) string {
	return fmt.Sprintf("%s:%s@tcp(%s)/%s?parseTime=true&amp;timeout=60s&amp;readTimeout=60s",
		dbUser,
		dbPassword,
		conn,
		dbName)
}

func buildPropertiesData() map[string]interface{} {
	return map[string]interface{}{
		"page": "/",
	}
}

func buildBrowserData() map[string]interface{} {
	return map[string]interface{}{
		"name": "Safari",
		"os":   "Mac",
		"resolution": struct {
			X int `json:"x"`
			Y int `json:"y"`
		}{1920, 1080},
	}
}

func main() {
	dns := getDNSString("tutorial", "root", "tutorial", "localhost:3310")
	db, err := sql.Open("mysql", dns)
	if err != nil {
		panic(err)
	}
	err = db.Ping()
	if err != nil {
		panic(err)
	}
	defer db.Close()

	event := Event{
		Name:       "pageview",
		Properties: buildPropertiesData(),
		Browser:    buildBrowserData(),
	}

	insertedId, err := insertEvent(db, event)
	if err != nil {
		panic(err)
	}

	firstEvent := Event{}
	err = selectEventById(db, insertedId, &amp;firstEvent)
	if err != nil {
		panic(err)
	}

	fmt.Println("\nEvent fields:\n")

	fmt.Println("Id:         ", firstEvent.Id)
	fmt.Println("Name:       ", firstEvent.Name)
	fmt.Println("Properties: ", firstEvent.Properties)
	fmt.Println("Browser:    ", firstEvent.Browser)

	fmt.Println("\nJSON representation:\n")

	j, err := json.Marshal(firstEvent)
	if err != nil {
		panic(err)
	}
	fmt.Println(string(j))
}

</code></pre></div></div>

<h2 id="running-it"><strong>Running it</strong></h2>

<p>If you’ve read my article about <a href="https://www.linkedin.com/pulse/go-database-migrations-made-easy-example-using-mysql-tiago-melo/">database migrations in Go</a>, you’ll be familiar with the way I’m setting our <a href="https://www.mysql.com/">MySQL</a> database, through <a href="https://docs.docker.com/compose/">Docker Compose</a> and <a href="https://github.com/golang-migrate/migrate">golang-migrate</a> tools.</p>

<p>To run it, let’s issue “make run”:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tiago:~/develop/go/articles/mysql-with-json$ make run

Setting up local MySQL...

Creating volume "mysql-with-json_db-data" with local driver

Creating db ... done

MySQL not ready, sleeping for 5 secs...

MySQL not ready, sleeping for 5 secs...

MySQL not ready, sleeping for 5 secs...

... MySQL is up and running!

Running migrations...

1/u events (42.932122ms)

Event fields:

Id:          1

Name:        pageview

Properties:  map[page:/]

Browser:     map[name:Safari os:Mac resolution:map[x:1920 y:1080]]

JSON representation:

{"id":1,"name":"pageview","properties":{"page":"/"},"browser {"name":"Safari","os":"Mac","resolution":{"x":1920,"y":1080}}}

</code></pre></div></div>

<ul>
  <li>invoked docker-compose to setup our MySQL container;</li>
  <li>waited for it to be ready, and then migrated the database;</li>
  <li>inserted a sample event in “events” table;</li>
  <li>used the returned id from the inserted event to query it up;</li>
  <li>then we did the output for both fields and for the struct’s <a href="https://www.json.org/">JSON</a> representation.</li>
</ul>

<p>Now let’s check our table:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tiago:~/develop/go/articles/mysql-with-json$ docker ps

CONTAINER ID   IMAGE       COMMAND                  CREATED              STATUS              PORTS                                         NAMES

288d45771919   mysql:5.7   "docker-entrypoint.s…"   About a minute ago   Up About a minute   3310/tcp, 33060/tcp, 0.0.0.0:3310-&gt;3306/tcp   db

tiago:~/develop/go/articles/mysql-with-json$ docker exec -it db /bin/bash

root@288d45771919:/# mysql -uroot -p -D tutorial

Enter password:

Reading table information for completion of table and column names

You can turn off this feature to get a quicker startup with -A

Welcome to the MySQL monitor.  Commands end with ; or \g.

Your MySQL connection id is 6

Server version: 5.7.32 MySQL Community Server (GPL)

Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its

affiliates. Other names may be trademarks of their respective

owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql&gt; select * from events;

+----+----------+---------------+-----------------------------------------------------------------------+

| id | name     | properties    | browser                                                               |

+----+----------+---------------+-----------------------------------------------------------------------+

|  1 | pageview | {"page": "/"} | {"os": "Mac", "name": "Safari", "resolution": {"x": 1920, "y": 1080}} |

+----+----------+---------------+-----------------------------------------------------------------------+

1 row in set (0.00 sec)

</code></pre></div></div>

<ul>
  <li>connected to our <a href="https://www.mysql.com/">MySQL</a> container;</li>
  <li>used its mysql client to connect to the database;</li>
  <li>queried the table.</li>
</ul>

<p>Pretty cool!</p>

<h2 id="running-it-in-mysql-56"><strong>Running it in MySQL 5.6</strong></h2>

<p>Since <a href="https://www.mysql.com/">MySQL</a> 5.6 does not recognize the “json” datatype, all you need to do is to use the “text” type and it will work:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE TABLE events(
  id int auto_increment primary key,
  name varchar(255),
  properties text,
  browser text
);

</code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>

<p>In this article we saw how we can leverage the use of interfaces in <a href="https://golang.org/">Go</a> so complex operations like reading/writing <a href="https://www.json.org/">JSON</a> to a <a href="https://www.mysql.com/">MySQL</a> table doesn’t pollute our code.</p>

<h2 id="download-the-source"><strong>Download the source</strong></h2>

<p>Here: <a href="https://bitbucket.org/tiagoharris/mysql-with-json">https://bitbucket.org/tiagoharris/mysql-with-json</a></p>
